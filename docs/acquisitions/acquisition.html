<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>dempy.acquisitions.acquisition API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dempy.acquisitions.acquisition</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import platform
import subprocess
from itertools import chain
from typing import Union, List, Dict, Any, Callable, ByteString

import matplotlib as mpt
import matplotlib.pyplot as plt
import matplotlib.ticker as ticker

from dempy import cache, _api_calls
from dempy._base import Entity
from dempy._protofiles import AcquisitionMessage
from dempy.acquisitions._utils import SampleList, AnnotationList
from dempy.acquisitions.annotation import Annotation
from dempy.acquisitions.device import Device
from dempy.acquisitions.image_sample import ImageSample
from dempy.acquisitions.sensor import Sensor
from dempy.acquisitions.subject import Subject
from dempy.acquisitions.timeseries_sample import TimeseriesSample
from dempy.acquisitions.video_sample import VideoSample

mpt.use(&#34;TkAgg&#34;)


class Acquisition(Entity):
    &#34;&#34;&#34;Acquisition class&#34;&#34;&#34;
    def __init__(self, type: str, id: str, tags: List[str], metadata: Dict[str, str], creation_timestamp: int, sync_offset: int,
                 time_unit: str, owner_id: str, creator_id: str, dataset_id: str, subject: Subject, devices: List[Device],
                 has_timeseries_samples: bool, has_image_samples: bool, has_video_samples: bool):
        super().__init__(type, id, tags, metadata)
        self.creation_timestamp = creation_timestamp
        self.sync_offset = sync_offset
        self.time_unit = time_unit
        self.owner_id = owner_id
        self.creator_id = creator_id
        self.dataset_id = dataset_id
        self.has_timeseries_samples = has_timeseries_samples
        self.has_image_samples = has_image_samples
        self.has_video_samples = has_video_samples
        self._subject = subject
        self._devices = devices

    @property
    def subject(self):    
        &#34;&#34;&#34;Subject&#39;s API&#34;&#34;&#34;
        class Inner:
            _SUBJECT_ENDPOINT = _ENDPOINT + &#34;{}/subjects/&#34;.format(self.id)

            @staticmethod
            def get() -&gt; Subject:
                &#34;&#34;&#34;Get subject from acquisition

                Returns:
                    Subject -- subject of the acquisition
                &#34;&#34;&#34;
                return self._subject

        return Inner()

    @property
    def devices(self):
        &#34;&#34;&#34;Devices&#39; API&#34;&#34;&#34;
        class Inner:
            _DEVICES_ENDPOINT = _ENDPOINT + &#34;{}/devices/&#34;.format(self.id)

            @staticmethod
            def get(device_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[Device, List[Device]]:
                &#34;&#34;&#34;Get a device identified by `device_id` or list of devices on this acquisition

                Keyword Arguments:
                    device_id {str} -- id of the device (default: {None})
                    tags {List[str]} -- tags of the devices (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the devices (default: {{}})

                Raises:
                    IndexError: device identified by `device_id` does not exist in this acquisition

                Returns:
                    Union[Device, List[Device]] -- device or list of devices
                &#34;&#34;&#34;
                if device_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        return [d for d in self._devices if
                                len([k for k in d.metadata if k in metadata and d.metadata[k] == metadata[k]]) &gt; 0]

                    return self._devices
                else:
                    try:
                        device = next((device for device in self._devices if device.id == device_id))
                    except StopIteration:
                        raise IndexError(f&#34;device id {device_id} does not exist in acquisition id {self.id}&#34;)
                    return device

            @staticmethod
            def usage() -&gt; Dict[str, List[str]]:
                &#34;&#34;&#34;Get a map identifying which device(s) and sensor(s) were used to acquire time series samples

                Returns:
                    Mapping[str, List[str]] -- map of (key, value) pairs, with key being id of device and the value
                    a list of sensor ids which were used to capture samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._DEVICES_ENDPOINT + &#34;usage&#34;).json()

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of devices on this acquisition

                Returns:
                    int -- number of devices
                &#34;&#34;&#34;
                return len(self._devices)

        return Inner()

    @property
    def timeseries_samples(self):
        &#34;&#34;&#34;Timeseries samples&#39; API&#34;&#34;&#34;
        class Inner:
            _TIMESERIES_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/timeseries/&#34;.format(self.id)

            @staticmethod
            def get(tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; SampleList:
                &#34;&#34;&#34;Get all the timeseries samples that belong to this acquisition

                Keyword Arguments:
                    tags {List[str]} -- tags of the timeseries samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the timeseries samples (default: {{}})

                Returns:
                    SampleList -- list of timeseries samples
                &#34;&#34;&#34;
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                    samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                        .json(object_hook=TimeseriesSample.from_json)
                    samples.sort(key=lambda sample: sample.timestamp)
                    return SampleList(samples)

                try:
                    samples = cache._get_cached_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, SampleList.from_protobuf)
                except FileNotFoundError:
                    samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT) \
                        .json(object_hook=TimeseriesSample.from_json)
                    samples.sort(key=lambda sample: sample.timestamp)
                    samples = SampleList(samples)
                    cache._cache_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, samples, SampleList.to_protobuf)
                return samples

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of timeseries samples on this acquisition

                Returns:
                    int -- number of timeseries samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(device_id: str, sensor_id: str = None) -&gt; None:
                &#34;&#34;&#34;Graphically visualize the timeseries samples of a device identified by `device_id` 
                or of a given sensor identified by `sensor_id` of said device

                Arguments:
                    device_id {str} -- id of the device

                Keyword Arguments:
                    sensor_id {str} -- id of the sensor (default: {None})
                &#34;&#34;&#34;
                def visualize_sensor_samples(axis, sensor, sensor_samples):
                    timestamps = [s.timestamp for s in sensor_samples]

                    # Sample x, y, z, u, w
                    samples_x = [s.x for s in sensor_samples if hasattr(s, &#34;x&#34;)]
                    samples_y = [s.y for s in sensor_samples if hasattr(s, &#34;y&#34;)]
                    samples_z = [s.z for s in sensor_samples if hasattr(s, &#34;z&#34;)]
                    samples_u = [s.u for s in sensor_samples if hasattr(s, &#34;u&#34;)]
                    samples_w = [s.w for s in sensor_samples if hasattr(s, &#34;w&#34;)]

                    # Title and x label
                    axis.set_title(f&#34;{sensor.sensor_type}\n{sensor.id}&#34;, loc=&#34;left&#34;)
                    axis.set_xlabel(sensor.time_unit if sensor.time_unit is not None else device_time_unit)

                    # Axis limit
                    axis.set_xlim([0, timestamps[-1]])
                    axis.set_ylim([min(chain(samples_x, samples_y, samples_z, samples_u, samples_w)),
                                   max(chain(samples_x, samples_y, samples_z, samples_u, samples_w))])

                    # Axis formatter
                    axis.xaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))
                    axis.yaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))

                    # Axis plot
                    labels = []

                    if len(samples_x) &gt; 0:
                        axis.plot(timestamps, samples_x, color=&#34;cornflowerblue&#34;)
                        labels.append(&#34;x&#34;)
                    if len(samples_y) &gt; 0:
                        axis.plot(timestamps, samples_y, color=&#34;mediumseagreen&#34;)
                        labels.append(&#34;y&#34;)
                    if len(samples_z) &gt; 0:
                        axis.plot(timestamps, samples_z, color=&#34;indianred&#34;)
                        labels.append(&#34;z&#34;)
                    if len(samples_u) &gt; 0:
                        axis.plot(timestamps, samples_u, color=&#34;mediumorchid&#34;)
                        labels.append(&#34;u&#34;)
                    if len(samples_w) &gt; 0:
                        axis.plot(timestamps, samples_w, color=&#34;slategray&#34;)
                        labels.append(&#34;w&#34;)

                    axis.legend(labels=labels, loc=&#34;upper right&#34;)

                device = self.devices.get(device_id=device_id)
                device_time_unit = device.time_unit if device.time_unit is not None else self.time_unit

                if sensor_id is None:
                    fig, axs = plt.subplots(nrows=device.sensors.count(), figsize=(15, 10), dpi=80, constrained_layout=True)
                    fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                    device_samples = self.timeseries_samples.get().by_device(device_id=device.id)

                    for i, sensor in enumerate(device.sensors.get()):
                        visualize_sensor_samples(axs[i], sensor, device_samples.by_sensor(sensor.id))
                else:
                    fig, ax = plt.subplots(nrows=1, figsize=(10, 4), dpi=80, constrained_layout=True)
                    fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                    sensor_samples = self.timeseries_samples.get().by_sensor(sensor_id)

                    visualize_sensor_samples(ax, device.sensors.get(sensor_id=sensor_id), sensor_samples)

                plt.show()

        return Inner()

    @property
    def image_samples(self):
        &#34;&#34;&#34;Image samples&#39; API&#34;&#34;&#34;
        class Inner:
            _IMAGE_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/images/&#34;.format(self.id)

            @staticmethod
            def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[ImageSample, SampleList]:
                &#34;&#34;&#34;Get all the image samples that belong to this acquisition

                Keyword Arguments:
                    sample_id {str} -- id of the sample (default: {None})
                    tags {List[str]} -- tags of image samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

                Returns:
                    Union[ImageSample, SampleList] -- image sample or list of image samples
                &#34;&#34;&#34;
                if sample_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=ImageSample.from_json)
                        return SampleList(samples)

                    samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT).json(object_hook=ImageSample.from_json)
                    for sample in samples:
                        cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample.id, sample, ImageSample.to_protobuf)
                    return SampleList(samples)
                else:
                    try:
                        sample = cache._get_cached_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, ImageSample.from_protobuf)
                    except FileNotFoundError:
                        sample = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id).json(object_hook=ImageSample.from_json)
                        cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, sample, ImageSample.to_protobuf)
                    return sample

            @staticmethod
            def raw(sample_id: str) -&gt; ByteString:
                &#34;&#34;&#34;Get actual image from image sample identified by `sample_id` on this acquisition

                Arguments:
                    sample_id {str} -- id of the sample

                Returns:
                    ByteString -- bytes of the image
                &#34;&#34;&#34;
                try:
                    image = cache._get_cached_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
                except FileNotFoundError:
                    image = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                    file_ext = &#34;.&#34; + image.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                    cache._cache_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id + file_ext, image.content)

                return image

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of image samples on this acquisition

                Returns:
                    int -- number of image samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
                &#34;&#34;&#34;Visualize the image of a sample identified by `sample_id`.
                By default opens the predefined system image application.
                A different callback can be given to open the image.

                Arguments:
                    sample_id {str} -- id of the sample

                Keyword Arguments:
                    backend {Callable[[str], None]} -- backend to open the image with (default: {None})
                &#34;&#34;&#34;
                self.image_samples.raw(sample_id)
                image_path = cache._build_cache_path(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
                image_path = cache._add_file_extension(image_path)

                if backend is None:
                    system = platform.system()

                    if system == &#34;Darwin&#34;:
                        subprocess.call((&#34;open&#34;, image_path))
                    elif system == &#34;Windows&#34;:
                        os.startfile(image_path)
                    else:
                        subprocess.call((&#34;xdg-open&#34;, image_path))
                else:
                    backend(image_path)

        return Inner()

    @property
    def video_samples(self):
        &#34;&#34;&#34;Video samples&#39; API&#34;&#34;&#34;
        class Inner:
            _VIDEO_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/videos/&#34;.format(self.id)

            @staticmethod
            def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[VideoSample, SampleList]:
                &#34;&#34;&#34;Get all the video samples that belong to this acquisition

                Keyword Arguments:
                    sample_id {str} -- id of the sample (default: {None})
                    tags {List[str]} -- tags of image samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

                Returns:
                    Union[VideoSample, SampleList] -- video sample or list of video samples
                &#34;&#34;&#34;
                if sample_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=VideoSample.from_json)
                        return SampleList(samples)

                    samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT).json(object_hook=VideoSample.from_json)
                    for sample in samples:
                        cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample.id, sample, VideoSample.to_protobuf)
                    return SampleList(samples)
                else:
                    try:
                        sample = cache._get_cached_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, VideoSample.from_protobuf)
                    except FileNotFoundError:
                        sample = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id).json(object_hook=VideoSample.from_json)
                        cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, sample, VideoSample.to_protobuf)
                    return sample

            @staticmethod
            def raw(sample_id: str) -&gt; ByteString:
                &#34;&#34;&#34;Get actual video from video sample identified by `sample_id` on this acquisition 

                Arguments:
                    sample_id {str} -- id of the sample

                Returns:
                    ByteString -- bytes of the video
                &#34;&#34;&#34;
                try:
                    video = cache._get_cached_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
                except FileNotFoundError:
                    video = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                    file_ext = &#34;.&#34; + video.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                    cache._cache_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id + file_ext, video.content)

                return video

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of video samples on this acquisition

                Returns:
                    int -- number of video samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
                &#34;&#34;&#34;Visualize the video of a sample identified by `sample_id`.
                By default opens the predefined system video application.
                A different callback can be given to open the video.

                Arguments:
                    sample_id {str} -- id of the sample

                Keyword Arguments:
                    backend {Callable[[str], None]} -- backend to open the video with (default: {None})
                &#34;&#34;&#34;
                self.video_samples.raw(sample_id)
                video_path = cache._build_cache_path(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
                video_path = cache._add_file_extension(video_path)

                if backend is None:
                    system = platform.system()

                    if system == &#34;Darwin&#34;:
                        subprocess.call((&#34;open&#34;, video_path))
                    elif system == &#34;Windows&#34;:
                        os.startfile(video_path)
                    else:
                        subprocess.call((&#34;xdg-open&#34;, video_path))
                else:
                    backend(video_path)

        return Inner()

    @property
    def annotations(self):
        &#34;&#34;&#34;Annotations&#39; API&#34;&#34;&#34;
        class Inner:
            _ANNOTATIONS_ENDPOINT = _ENDPOINT + &#34;{}/annotations/&#34;.format(self.id)

            @staticmethod
            def get(annotation_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; AnnotationList:
                &#34;&#34;&#34;Get all the annotations that belong to this acquisition

                Keyword Arguments:
                    annotation_id {str} -- id of the annotation (default: {None})
                    tags {List[str]} -- tags of the annotation (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the annotation (default: {{}})

                Returns:
                    AnnotationList -- annotation or annotation of video samples
                &#34;&#34;&#34;
                if annotation_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=Annotation.from_json)
                        return AnnotationList(annotations)

                    annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT).json(object_hook=Annotation.from_json)
                    for annotation in annotations:
                        cache._cache_data(&#34;annotations&#34;, annotation.id, annotation, Annotation.to_protobuf)
                    return AnnotationList(annotations)
                else:
                    try:
                        annotation = cache._get_cached_data(&#34;annotations&#34;, annotation_id, Annotation.from_protobuf)
                    except FileNotFoundError:
                        annotation = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + annotation_id).json(object_hook=Annotation.from_json)
                        cache._cache_data(&#34;annotations&#34;, annotation_id, annotation, Annotation.to_protobuf)
                    return annotation

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of annotations on this acquisition

                Returns:
                    int -- number of annotations
                &#34;&#34;&#34;
                return _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + &#34;count&#34;).json()

        return Inner()

    @staticmethod
    def to_protobuf(obj: &#34;Acquisition&#34;) -&gt; AcquisitionMessage:
        &#34;&#34;&#34;Encode an acquisition to a Protobuf message

        Arguments:
            obj {Acquisition} -- acquisition to be encoded

        Returns:
            AcquisitionMessage -- encoded acquisition
        &#34;&#34;&#34;
        acquisition_message = AcquisitionMessage()
        acquisition_message.entity.CopyFrom(Entity.to_protobuf(obj))
        acquisition_message.creation_timestamp = obj.creation_timestamp

        if obj.sync_offset is not None:
            acquisition_message.sync_offset = obj.sync_offset
        if obj.time_unit is not None:
            acquisition_message.time_unit = obj.time_unit
        if obj.owner_id is not None:
            acquisition_message.owner_id = obj.owner_id
        if obj.creator_id is not None:
            acquisition_message.creator_id = obj.creator_id
        if obj.dataset_id is not None:
            acquisition_message.dataset_id = obj.dataset_id

        acquisition_message.subject.CopyFrom(Subject.to_protobuf(obj._subject))
        acquisition_message.devices.extend([Device.to_protobuf(d) for d in obj._devices])
        acquisition_message.has_timeseries_samples = obj.has_timeseries_samples
        acquisition_message.has_image_samples = obj.has_image_samples
        acquisition_message.has_video_samples = obj.has_video_samples

        return acquisition_message

    @staticmethod
    def from_protobuf(obj: ByteString) -&gt; &#34;Acquisition&#34;:
        &#34;&#34;&#34;Decode a Protobuf message to {Acquisition}

        Arguments:
            obj {ByteString} -- message to be decoded

        Returns:
            Acquisition -- decoded acquisition
        &#34;&#34;&#34;
        acquisition_message = AcquisitionMessage()
        acquisition_message.ParseFromString(obj)

        return Acquisition(
            type=acquisition_message.entity.type,
            id=acquisition_message.entity.id,
            tags=acquisition_message.entity.tags,
            metadata=acquisition_message.entity.metadata,
            creation_timestamp=acquisition_message.creation_timestamp,
            sync_offset=acquisition_message.sync_offset if acquisition_message.HasField(&#34;sync_offset&#34;) else None,
            time_unit=acquisition_message.time_unit,
            owner_id=acquisition_message.owner_id if acquisition_message.HasField(&#34;owner_id&#34;) else None,
            creator_id=acquisition_message.creator_id if acquisition_message.HasField(&#34;creator_id&#34;) else None,
            dataset_id=acquisition_message.dataset_id if acquisition_message.HasField(&#34;dataset_id&#34;) else None,
            subject=Subject.from_protobuf(acquisition_message.subject),
            devices=[Device.from_protobuf(d) for d in acquisition_message.devices],
            has_timeseries_samples=acquisition_message.has_timeseries_samples,
            has_image_samples=acquisition_message.has_image_samples,
            has_video_samples=acquisition_message.has_video_samples
        )

    @staticmethod
    def from_json(obj: Dict[str, str]) -&gt; Any:
        &#34;&#34;&#34;Parse a JSON dictionary to {Acquisition}

        Arguments:
            obj {Dict[str, str]} -- JSON object

        Raises:
            ValueError: unexpected object or sub-object

        Returns:
            Any -- parsed object and sub-objects
        &#34;&#34;&#34;
        if &#34;type&#34; in obj:
            if obj[&#34;type&#34;] == &#34;Acquisition&#34;:
                return Acquisition(
                    type=obj[&#34;type&#34;],
                    id=obj[&#34;id&#34;],
                    tags=obj[&#34;tags&#34;],
                    metadata=obj[&#34;metadata&#34;],
                    creation_timestamp=obj[&#34;creationTimestamp&#34;],
                    sync_offset=obj[&#34;syncOffset&#34;],
                    time_unit=obj[&#34;timeUnit&#34;],
                    owner_id=obj[&#34;ownerId&#34;],
                    creator_id=obj[&#34;creatorId&#34;],
                    dataset_id=obj[&#34;datasetId&#34;],
                    subject=obj[&#34;subject&#34;],
                    devices=obj[&#34;devices&#34;],
                    has_timeseries_samples=obj[&#34;hasTimeSeriesSamples&#34;],
                    has_image_samples=obj[&#34;hasImageSamples&#34;],
                    has_video_samples=obj[&#34;hasVideoSamples&#34;]
                )
            elif obj[&#34;type&#34;].endswith(&#34;Subject&#34;):
                return Subject.from_json(obj)
            elif obj[&#34;type&#34;] == &#34;Device&#34;:
                return Device.from_json(obj)
            elif obj[&#34;type&#34;] == &#34;Sensor&#34;:
                return Sensor.from_json(obj)
            else:
                raise ValueError

        return obj


_ENDPOINT = &#34;api/acquisitions/&#34;


def get(acquisition_id: str = None, dataset_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) \
    -&gt; Union[Acquisition, List[Acquisition]]:
    &#34;&#34;&#34;Get an acquisition identified by `acquisition_id` or a list of all the acquisitions

    Keyword Arguments:
        acquisition_id {str} -- id of the acquisition (default: {None})
        dataset_id {str} -- id of the dataset to which the acquisitions belong to (default: {None})
        tags {List[str]} -- tags of the acquisitions (default: {[]})
        metadata {Dict[str, str]} -- metadata of the acquisitions (default: {{}})

    Returns:
        Union[Acquisition, List[Acquisition]] -- acquisition or list of acquisitions
    &#34;&#34;&#34;
    if acquisition_id is None:
        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
        acquisitions = _api_calls.get(_ENDPOINT, params={&#34;datasetId&#34;: dataset_id, &#34;tags&#34;: tags, **processed_metadata}) \
            .json(object_hook=Acquisition.from_json)
        for acquisition in acquisitions:
            cache._cache_data(&#34;acquisitions&#34;, acquisition.id, acquisition, Acquisition.to_protobuf)
        return acquisitions
    else:
        try:
            acquisition = cache._get_cached_data(&#34;acquisitions&#34;, acquisition_id, Acquisition.from_protobuf)
        except FileNotFoundError:
            acquisition = _api_calls.get(_ENDPOINT + acquisition_id).json(object_hook=Acquisition.from_json)
            cache._cache_data(&#34;acquisitions&#34;, acquisition_id, acquisition, Acquisition.to_protobuf)
        return acquisition


def count() -&gt; int:
    &#34;&#34;&#34;Get number of acquisitions

    Returns:
        int -- number of acquisitions
    &#34;&#34;&#34;
    return _api_calls.get(_ENDPOINT + &#34;count&#34;).json()


__all__ = [
    &#34;Acquisition&#34;,
    &#34;get&#34;, &#34;count&#34;
]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dempy.acquisitions.acquisition.count"><code class="name flex">
<span>def <span class="ident">count</span></span>(<span>) -> int</span>
</code></dt>
<dd>
<div class="desc"><p>Get number of acquisitions</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int -- number</code> of <code>acquisitions</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def count() -&gt; int:
    &#34;&#34;&#34;Get number of acquisitions

    Returns:
        int -- number of acquisitions
    &#34;&#34;&#34;
    return _api_calls.get(_ENDPOINT + &#34;count&#34;).json()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>acquisition_id: str = None, dataset_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -> Union[<a title="dempy.acquisitions.acquisition.Acquisition" href="#dempy.acquisitions.acquisition.Acquisition">Acquisition</a>, List[<a title="dempy.acquisitions.acquisition.Acquisition" href="#dempy.acquisitions.acquisition.Acquisition">Acquisition</a>]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get an acquisition identified by <code>acquisition_id</code> or a list of all the acquisitions</p>
<p>Keyword Arguments:
acquisition_id {str} &ndash; id of the acquisition (default: {None})
dataset_id {str} &ndash; id of the dataset to which the acquisitions belong to (default: {None})
tags {List[str]} &ndash; tags of the acquisitions (default: {[]})
metadata {Dict[str, str]} &ndash; metadata of the acquisitions (default: {{}})</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[Acquisition, List[Acquisition]] -- acquisition</code> or <code>list</code> of <code>acquisitions</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get(acquisition_id: str = None, dataset_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) \
    -&gt; Union[Acquisition, List[Acquisition]]:
    &#34;&#34;&#34;Get an acquisition identified by `acquisition_id` or a list of all the acquisitions

    Keyword Arguments:
        acquisition_id {str} -- id of the acquisition (default: {None})
        dataset_id {str} -- id of the dataset to which the acquisitions belong to (default: {None})
        tags {List[str]} -- tags of the acquisitions (default: {[]})
        metadata {Dict[str, str]} -- metadata of the acquisitions (default: {{}})

    Returns:
        Union[Acquisition, List[Acquisition]] -- acquisition or list of acquisitions
    &#34;&#34;&#34;
    if acquisition_id is None:
        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
        acquisitions = _api_calls.get(_ENDPOINT, params={&#34;datasetId&#34;: dataset_id, &#34;tags&#34;: tags, **processed_metadata}) \
            .json(object_hook=Acquisition.from_json)
        for acquisition in acquisitions:
            cache._cache_data(&#34;acquisitions&#34;, acquisition.id, acquisition, Acquisition.to_protobuf)
        return acquisitions
    else:
        try:
            acquisition = cache._get_cached_data(&#34;acquisitions&#34;, acquisition_id, Acquisition.from_protobuf)
        except FileNotFoundError:
            acquisition = _api_calls.get(_ENDPOINT + acquisition_id).json(object_hook=Acquisition.from_json)
            cache._cache_data(&#34;acquisitions&#34;, acquisition_id, acquisition, Acquisition.to_protobuf)
        return acquisition</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dempy.acquisitions.acquisition.Acquisition"><code class="flex name class">
<span>class <span class="ident">Acquisition</span></span>
<span>(</span><span>type: str, id: str, tags: List[str], metadata: Dict[str, str], creation_timestamp: int, sync_offset: int, time_unit: str, owner_id: str, creator_id: str, dataset_id: str, subject: <a title="dempy.acquisitions.subject.Subject" href="subject.html#dempy.acquisitions.subject.Subject">Subject</a>, devices: List[<a title="dempy.acquisitions.device.Device" href="device.html#dempy.acquisitions.device.Device">Device</a>], has_timeseries_samples: bool, has_image_samples: bool, has_video_samples: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Acquisition class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Acquisition(Entity):
    &#34;&#34;&#34;Acquisition class&#34;&#34;&#34;
    def __init__(self, type: str, id: str, tags: List[str], metadata: Dict[str, str], creation_timestamp: int, sync_offset: int,
                 time_unit: str, owner_id: str, creator_id: str, dataset_id: str, subject: Subject, devices: List[Device],
                 has_timeseries_samples: bool, has_image_samples: bool, has_video_samples: bool):
        super().__init__(type, id, tags, metadata)
        self.creation_timestamp = creation_timestamp
        self.sync_offset = sync_offset
        self.time_unit = time_unit
        self.owner_id = owner_id
        self.creator_id = creator_id
        self.dataset_id = dataset_id
        self.has_timeseries_samples = has_timeseries_samples
        self.has_image_samples = has_image_samples
        self.has_video_samples = has_video_samples
        self._subject = subject
        self._devices = devices

    @property
    def subject(self):    
        &#34;&#34;&#34;Subject&#39;s API&#34;&#34;&#34;
        class Inner:
            _SUBJECT_ENDPOINT = _ENDPOINT + &#34;{}/subjects/&#34;.format(self.id)

            @staticmethod
            def get() -&gt; Subject:
                &#34;&#34;&#34;Get subject from acquisition

                Returns:
                    Subject -- subject of the acquisition
                &#34;&#34;&#34;
                return self._subject

        return Inner()

    @property
    def devices(self):
        &#34;&#34;&#34;Devices&#39; API&#34;&#34;&#34;
        class Inner:
            _DEVICES_ENDPOINT = _ENDPOINT + &#34;{}/devices/&#34;.format(self.id)

            @staticmethod
            def get(device_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[Device, List[Device]]:
                &#34;&#34;&#34;Get a device identified by `device_id` or list of devices on this acquisition

                Keyword Arguments:
                    device_id {str} -- id of the device (default: {None})
                    tags {List[str]} -- tags of the devices (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the devices (default: {{}})

                Raises:
                    IndexError: device identified by `device_id` does not exist in this acquisition

                Returns:
                    Union[Device, List[Device]] -- device or list of devices
                &#34;&#34;&#34;
                if device_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        return [d for d in self._devices if
                                len([k for k in d.metadata if k in metadata and d.metadata[k] == metadata[k]]) &gt; 0]

                    return self._devices
                else:
                    try:
                        device = next((device for device in self._devices if device.id == device_id))
                    except StopIteration:
                        raise IndexError(f&#34;device id {device_id} does not exist in acquisition id {self.id}&#34;)
                    return device

            @staticmethod
            def usage() -&gt; Dict[str, List[str]]:
                &#34;&#34;&#34;Get a map identifying which device(s) and sensor(s) were used to acquire time series samples

                Returns:
                    Mapping[str, List[str]] -- map of (key, value) pairs, with key being id of device and the value
                    a list of sensor ids which were used to capture samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._DEVICES_ENDPOINT + &#34;usage&#34;).json()

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of devices on this acquisition

                Returns:
                    int -- number of devices
                &#34;&#34;&#34;
                return len(self._devices)

        return Inner()

    @property
    def timeseries_samples(self):
        &#34;&#34;&#34;Timeseries samples&#39; API&#34;&#34;&#34;
        class Inner:
            _TIMESERIES_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/timeseries/&#34;.format(self.id)

            @staticmethod
            def get(tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; SampleList:
                &#34;&#34;&#34;Get all the timeseries samples that belong to this acquisition

                Keyword Arguments:
                    tags {List[str]} -- tags of the timeseries samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the timeseries samples (default: {{}})

                Returns:
                    SampleList -- list of timeseries samples
                &#34;&#34;&#34;
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                    samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                        .json(object_hook=TimeseriesSample.from_json)
                    samples.sort(key=lambda sample: sample.timestamp)
                    return SampleList(samples)

                try:
                    samples = cache._get_cached_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, SampleList.from_protobuf)
                except FileNotFoundError:
                    samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT) \
                        .json(object_hook=TimeseriesSample.from_json)
                    samples.sort(key=lambda sample: sample.timestamp)
                    samples = SampleList(samples)
                    cache._cache_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, samples, SampleList.to_protobuf)
                return samples

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of timeseries samples on this acquisition

                Returns:
                    int -- number of timeseries samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(device_id: str, sensor_id: str = None) -&gt; None:
                &#34;&#34;&#34;Graphically visualize the timeseries samples of a device identified by `device_id` 
                or of a given sensor identified by `sensor_id` of said device

                Arguments:
                    device_id {str} -- id of the device

                Keyword Arguments:
                    sensor_id {str} -- id of the sensor (default: {None})
                &#34;&#34;&#34;
                def visualize_sensor_samples(axis, sensor, sensor_samples):
                    timestamps = [s.timestamp for s in sensor_samples]

                    # Sample x, y, z, u, w
                    samples_x = [s.x for s in sensor_samples if hasattr(s, &#34;x&#34;)]
                    samples_y = [s.y for s in sensor_samples if hasattr(s, &#34;y&#34;)]
                    samples_z = [s.z for s in sensor_samples if hasattr(s, &#34;z&#34;)]
                    samples_u = [s.u for s in sensor_samples if hasattr(s, &#34;u&#34;)]
                    samples_w = [s.w for s in sensor_samples if hasattr(s, &#34;w&#34;)]

                    # Title and x label
                    axis.set_title(f&#34;{sensor.sensor_type}\n{sensor.id}&#34;, loc=&#34;left&#34;)
                    axis.set_xlabel(sensor.time_unit if sensor.time_unit is not None else device_time_unit)

                    # Axis limit
                    axis.set_xlim([0, timestamps[-1]])
                    axis.set_ylim([min(chain(samples_x, samples_y, samples_z, samples_u, samples_w)),
                                   max(chain(samples_x, samples_y, samples_z, samples_u, samples_w))])

                    # Axis formatter
                    axis.xaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))
                    axis.yaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))

                    # Axis plot
                    labels = []

                    if len(samples_x) &gt; 0:
                        axis.plot(timestamps, samples_x, color=&#34;cornflowerblue&#34;)
                        labels.append(&#34;x&#34;)
                    if len(samples_y) &gt; 0:
                        axis.plot(timestamps, samples_y, color=&#34;mediumseagreen&#34;)
                        labels.append(&#34;y&#34;)
                    if len(samples_z) &gt; 0:
                        axis.plot(timestamps, samples_z, color=&#34;indianred&#34;)
                        labels.append(&#34;z&#34;)
                    if len(samples_u) &gt; 0:
                        axis.plot(timestamps, samples_u, color=&#34;mediumorchid&#34;)
                        labels.append(&#34;u&#34;)
                    if len(samples_w) &gt; 0:
                        axis.plot(timestamps, samples_w, color=&#34;slategray&#34;)
                        labels.append(&#34;w&#34;)

                    axis.legend(labels=labels, loc=&#34;upper right&#34;)

                device = self.devices.get(device_id=device_id)
                device_time_unit = device.time_unit if device.time_unit is not None else self.time_unit

                if sensor_id is None:
                    fig, axs = plt.subplots(nrows=device.sensors.count(), figsize=(15, 10), dpi=80, constrained_layout=True)
                    fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                    device_samples = self.timeseries_samples.get().by_device(device_id=device.id)

                    for i, sensor in enumerate(device.sensors.get()):
                        visualize_sensor_samples(axs[i], sensor, device_samples.by_sensor(sensor.id))
                else:
                    fig, ax = plt.subplots(nrows=1, figsize=(10, 4), dpi=80, constrained_layout=True)
                    fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                    sensor_samples = self.timeseries_samples.get().by_sensor(sensor_id)

                    visualize_sensor_samples(ax, device.sensors.get(sensor_id=sensor_id), sensor_samples)

                plt.show()

        return Inner()

    @property
    def image_samples(self):
        &#34;&#34;&#34;Image samples&#39; API&#34;&#34;&#34;
        class Inner:
            _IMAGE_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/images/&#34;.format(self.id)

            @staticmethod
            def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[ImageSample, SampleList]:
                &#34;&#34;&#34;Get all the image samples that belong to this acquisition

                Keyword Arguments:
                    sample_id {str} -- id of the sample (default: {None})
                    tags {List[str]} -- tags of image samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

                Returns:
                    Union[ImageSample, SampleList] -- image sample or list of image samples
                &#34;&#34;&#34;
                if sample_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=ImageSample.from_json)
                        return SampleList(samples)

                    samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT).json(object_hook=ImageSample.from_json)
                    for sample in samples:
                        cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample.id, sample, ImageSample.to_protobuf)
                    return SampleList(samples)
                else:
                    try:
                        sample = cache._get_cached_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, ImageSample.from_protobuf)
                    except FileNotFoundError:
                        sample = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id).json(object_hook=ImageSample.from_json)
                        cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, sample, ImageSample.to_protobuf)
                    return sample

            @staticmethod
            def raw(sample_id: str) -&gt; ByteString:
                &#34;&#34;&#34;Get actual image from image sample identified by `sample_id` on this acquisition

                Arguments:
                    sample_id {str} -- id of the sample

                Returns:
                    ByteString -- bytes of the image
                &#34;&#34;&#34;
                try:
                    image = cache._get_cached_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
                except FileNotFoundError:
                    image = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                    file_ext = &#34;.&#34; + image.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                    cache._cache_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id + file_ext, image.content)

                return image

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of image samples on this acquisition

                Returns:
                    int -- number of image samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
                &#34;&#34;&#34;Visualize the image of a sample identified by `sample_id`.
                By default opens the predefined system image application.
                A different callback can be given to open the image.

                Arguments:
                    sample_id {str} -- id of the sample

                Keyword Arguments:
                    backend {Callable[[str], None]} -- backend to open the image with (default: {None})
                &#34;&#34;&#34;
                self.image_samples.raw(sample_id)
                image_path = cache._build_cache_path(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
                image_path = cache._add_file_extension(image_path)

                if backend is None:
                    system = platform.system()

                    if system == &#34;Darwin&#34;:
                        subprocess.call((&#34;open&#34;, image_path))
                    elif system == &#34;Windows&#34;:
                        os.startfile(image_path)
                    else:
                        subprocess.call((&#34;xdg-open&#34;, image_path))
                else:
                    backend(image_path)

        return Inner()

    @property
    def video_samples(self):
        &#34;&#34;&#34;Video samples&#39; API&#34;&#34;&#34;
        class Inner:
            _VIDEO_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/videos/&#34;.format(self.id)

            @staticmethod
            def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[VideoSample, SampleList]:
                &#34;&#34;&#34;Get all the video samples that belong to this acquisition

                Keyword Arguments:
                    sample_id {str} -- id of the sample (default: {None})
                    tags {List[str]} -- tags of image samples (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

                Returns:
                    Union[VideoSample, SampleList] -- video sample or list of video samples
                &#34;&#34;&#34;
                if sample_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=VideoSample.from_json)
                        return SampleList(samples)

                    samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT).json(object_hook=VideoSample.from_json)
                    for sample in samples:
                        cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample.id, sample, VideoSample.to_protobuf)
                    return SampleList(samples)
                else:
                    try:
                        sample = cache._get_cached_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, VideoSample.from_protobuf)
                    except FileNotFoundError:
                        sample = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id).json(object_hook=VideoSample.from_json)
                        cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, sample, VideoSample.to_protobuf)
                    return sample

            @staticmethod
            def raw(sample_id: str) -&gt; ByteString:
                &#34;&#34;&#34;Get actual video from video sample identified by `sample_id` on this acquisition 

                Arguments:
                    sample_id {str} -- id of the sample

                Returns:
                    ByteString -- bytes of the video
                &#34;&#34;&#34;
                try:
                    video = cache._get_cached_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
                except FileNotFoundError:
                    video = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                    file_ext = &#34;.&#34; + video.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                    cache._cache_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id + file_ext, video.content)

                return video

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of video samples on this acquisition

                Returns:
                    int -- number of video samples
                &#34;&#34;&#34;
                return _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + &#34;count&#34;).json()

            @staticmethod
            def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
                &#34;&#34;&#34;Visualize the video of a sample identified by `sample_id`.
                By default opens the predefined system video application.
                A different callback can be given to open the video.

                Arguments:
                    sample_id {str} -- id of the sample

                Keyword Arguments:
                    backend {Callable[[str], None]} -- backend to open the video with (default: {None})
                &#34;&#34;&#34;
                self.video_samples.raw(sample_id)
                video_path = cache._build_cache_path(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
                video_path = cache._add_file_extension(video_path)

                if backend is None:
                    system = platform.system()

                    if system == &#34;Darwin&#34;:
                        subprocess.call((&#34;open&#34;, video_path))
                    elif system == &#34;Windows&#34;:
                        os.startfile(video_path)
                    else:
                        subprocess.call((&#34;xdg-open&#34;, video_path))
                else:
                    backend(video_path)

        return Inner()

    @property
    def annotations(self):
        &#34;&#34;&#34;Annotations&#39; API&#34;&#34;&#34;
        class Inner:
            _ANNOTATIONS_ENDPOINT = _ENDPOINT + &#34;{}/annotations/&#34;.format(self.id)

            @staticmethod
            def get(annotation_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; AnnotationList:
                &#34;&#34;&#34;Get all the annotations that belong to this acquisition

                Keyword Arguments:
                    annotation_id {str} -- id of the annotation (default: {None})
                    tags {List[str]} -- tags of the annotation (default: {[]})
                    metadata {Dict[str, str]} -- metadata of the annotation (default: {{}})

                Returns:
                    AnnotationList -- annotation or annotation of video samples
                &#34;&#34;&#34;
                if annotation_id is None:
                    if len(tags) &gt; 0 or len(metadata) &gt; 0:
                        processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                        annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                            .json(object_hook=Annotation.from_json)
                        return AnnotationList(annotations)

                    annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT).json(object_hook=Annotation.from_json)
                    for annotation in annotations:
                        cache._cache_data(&#34;annotations&#34;, annotation.id, annotation, Annotation.to_protobuf)
                    return AnnotationList(annotations)
                else:
                    try:
                        annotation = cache._get_cached_data(&#34;annotations&#34;, annotation_id, Annotation.from_protobuf)
                    except FileNotFoundError:
                        annotation = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + annotation_id).json(object_hook=Annotation.from_json)
                        cache._cache_data(&#34;annotations&#34;, annotation_id, annotation, Annotation.to_protobuf)
                    return annotation

            @staticmethod
            def count() -&gt; int:
                &#34;&#34;&#34;Get the number of annotations on this acquisition

                Returns:
                    int -- number of annotations
                &#34;&#34;&#34;
                return _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + &#34;count&#34;).json()

        return Inner()

    @staticmethod
    def to_protobuf(obj: &#34;Acquisition&#34;) -&gt; AcquisitionMessage:
        &#34;&#34;&#34;Encode an acquisition to a Protobuf message

        Arguments:
            obj {Acquisition} -- acquisition to be encoded

        Returns:
            AcquisitionMessage -- encoded acquisition
        &#34;&#34;&#34;
        acquisition_message = AcquisitionMessage()
        acquisition_message.entity.CopyFrom(Entity.to_protobuf(obj))
        acquisition_message.creation_timestamp = obj.creation_timestamp

        if obj.sync_offset is not None:
            acquisition_message.sync_offset = obj.sync_offset
        if obj.time_unit is not None:
            acquisition_message.time_unit = obj.time_unit
        if obj.owner_id is not None:
            acquisition_message.owner_id = obj.owner_id
        if obj.creator_id is not None:
            acquisition_message.creator_id = obj.creator_id
        if obj.dataset_id is not None:
            acquisition_message.dataset_id = obj.dataset_id

        acquisition_message.subject.CopyFrom(Subject.to_protobuf(obj._subject))
        acquisition_message.devices.extend([Device.to_protobuf(d) for d in obj._devices])
        acquisition_message.has_timeseries_samples = obj.has_timeseries_samples
        acquisition_message.has_image_samples = obj.has_image_samples
        acquisition_message.has_video_samples = obj.has_video_samples

        return acquisition_message

    @staticmethod
    def from_protobuf(obj: ByteString) -&gt; &#34;Acquisition&#34;:
        &#34;&#34;&#34;Decode a Protobuf message to {Acquisition}

        Arguments:
            obj {ByteString} -- message to be decoded

        Returns:
            Acquisition -- decoded acquisition
        &#34;&#34;&#34;
        acquisition_message = AcquisitionMessage()
        acquisition_message.ParseFromString(obj)

        return Acquisition(
            type=acquisition_message.entity.type,
            id=acquisition_message.entity.id,
            tags=acquisition_message.entity.tags,
            metadata=acquisition_message.entity.metadata,
            creation_timestamp=acquisition_message.creation_timestamp,
            sync_offset=acquisition_message.sync_offset if acquisition_message.HasField(&#34;sync_offset&#34;) else None,
            time_unit=acquisition_message.time_unit,
            owner_id=acquisition_message.owner_id if acquisition_message.HasField(&#34;owner_id&#34;) else None,
            creator_id=acquisition_message.creator_id if acquisition_message.HasField(&#34;creator_id&#34;) else None,
            dataset_id=acquisition_message.dataset_id if acquisition_message.HasField(&#34;dataset_id&#34;) else None,
            subject=Subject.from_protobuf(acquisition_message.subject),
            devices=[Device.from_protobuf(d) for d in acquisition_message.devices],
            has_timeseries_samples=acquisition_message.has_timeseries_samples,
            has_image_samples=acquisition_message.has_image_samples,
            has_video_samples=acquisition_message.has_video_samples
        )

    @staticmethod
    def from_json(obj: Dict[str, str]) -&gt; Any:
        &#34;&#34;&#34;Parse a JSON dictionary to {Acquisition}

        Arguments:
            obj {Dict[str, str]} -- JSON object

        Raises:
            ValueError: unexpected object or sub-object

        Returns:
            Any -- parsed object and sub-objects
        &#34;&#34;&#34;
        if &#34;type&#34; in obj:
            if obj[&#34;type&#34;] == &#34;Acquisition&#34;:
                return Acquisition(
                    type=obj[&#34;type&#34;],
                    id=obj[&#34;id&#34;],
                    tags=obj[&#34;tags&#34;],
                    metadata=obj[&#34;metadata&#34;],
                    creation_timestamp=obj[&#34;creationTimestamp&#34;],
                    sync_offset=obj[&#34;syncOffset&#34;],
                    time_unit=obj[&#34;timeUnit&#34;],
                    owner_id=obj[&#34;ownerId&#34;],
                    creator_id=obj[&#34;creatorId&#34;],
                    dataset_id=obj[&#34;datasetId&#34;],
                    subject=obj[&#34;subject&#34;],
                    devices=obj[&#34;devices&#34;],
                    has_timeseries_samples=obj[&#34;hasTimeSeriesSamples&#34;],
                    has_image_samples=obj[&#34;hasImageSamples&#34;],
                    has_video_samples=obj[&#34;hasVideoSamples&#34;]
                )
            elif obj[&#34;type&#34;].endswith(&#34;Subject&#34;):
                return Subject.from_json(obj)
            elif obj[&#34;type&#34;] == &#34;Device&#34;:
                return Device.from_json(obj)
            elif obj[&#34;type&#34;] == &#34;Sensor&#34;:
                return Sensor.from_json(obj)
            else:
                raise ValueError

        return obj</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>dempy._base.Entity</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dempy.acquisitions.acquisition.Acquisition.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>obj: Dict[str, str]) -> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Parse a JSON dictionary to {Acquisition}</p>
<h2 id="arguments">Arguments</h2>
<p>obj {Dict[str, str]} &ndash; JSON object</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>unexpected object or sub-object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any -- parsed object and sub-objects</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(obj: Dict[str, str]) -&gt; Any:
    &#34;&#34;&#34;Parse a JSON dictionary to {Acquisition}

    Arguments:
        obj {Dict[str, str]} -- JSON object

    Raises:
        ValueError: unexpected object or sub-object

    Returns:
        Any -- parsed object and sub-objects
    &#34;&#34;&#34;
    if &#34;type&#34; in obj:
        if obj[&#34;type&#34;] == &#34;Acquisition&#34;:
            return Acquisition(
                type=obj[&#34;type&#34;],
                id=obj[&#34;id&#34;],
                tags=obj[&#34;tags&#34;],
                metadata=obj[&#34;metadata&#34;],
                creation_timestamp=obj[&#34;creationTimestamp&#34;],
                sync_offset=obj[&#34;syncOffset&#34;],
                time_unit=obj[&#34;timeUnit&#34;],
                owner_id=obj[&#34;ownerId&#34;],
                creator_id=obj[&#34;creatorId&#34;],
                dataset_id=obj[&#34;datasetId&#34;],
                subject=obj[&#34;subject&#34;],
                devices=obj[&#34;devices&#34;],
                has_timeseries_samples=obj[&#34;hasTimeSeriesSamples&#34;],
                has_image_samples=obj[&#34;hasImageSamples&#34;],
                has_video_samples=obj[&#34;hasVideoSamples&#34;]
            )
        elif obj[&#34;type&#34;].endswith(&#34;Subject&#34;):
            return Subject.from_json(obj)
        elif obj[&#34;type&#34;] == &#34;Device&#34;:
            return Device.from_json(obj)
        elif obj[&#34;type&#34;] == &#34;Sensor&#34;:
            return Sensor.from_json(obj)
        else:
            raise ValueError

    return obj</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.from_protobuf"><code class="name flex">
<span>def <span class="ident">from_protobuf</span></span>(<span>obj: ByteString) -> <a title="dempy.acquisitions.acquisition.Acquisition" href="#dempy.acquisitions.acquisition.Acquisition">Acquisition</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decode a Protobuf message to {Acquisition}</p>
<h2 id="arguments">Arguments</h2>
<p>obj {ByteString} &ndash; message to be decoded</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Acquisition -- decoded acquisition</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_protobuf(obj: ByteString) -&gt; &#34;Acquisition&#34;:
    &#34;&#34;&#34;Decode a Protobuf message to {Acquisition}

    Arguments:
        obj {ByteString} -- message to be decoded

    Returns:
        Acquisition -- decoded acquisition
    &#34;&#34;&#34;
    acquisition_message = AcquisitionMessage()
    acquisition_message.ParseFromString(obj)

    return Acquisition(
        type=acquisition_message.entity.type,
        id=acquisition_message.entity.id,
        tags=acquisition_message.entity.tags,
        metadata=acquisition_message.entity.metadata,
        creation_timestamp=acquisition_message.creation_timestamp,
        sync_offset=acquisition_message.sync_offset if acquisition_message.HasField(&#34;sync_offset&#34;) else None,
        time_unit=acquisition_message.time_unit,
        owner_id=acquisition_message.owner_id if acquisition_message.HasField(&#34;owner_id&#34;) else None,
        creator_id=acquisition_message.creator_id if acquisition_message.HasField(&#34;creator_id&#34;) else None,
        dataset_id=acquisition_message.dataset_id if acquisition_message.HasField(&#34;dataset_id&#34;) else None,
        subject=Subject.from_protobuf(acquisition_message.subject),
        devices=[Device.from_protobuf(d) for d in acquisition_message.devices],
        has_timeseries_samples=acquisition_message.has_timeseries_samples,
        has_image_samples=acquisition_message.has_image_samples,
        has_video_samples=acquisition_message.has_video_samples
    )</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.to_protobuf"><code class="name flex">
<span>def <span class="ident">to_protobuf</span></span>(<span>obj: Acquisition) -> dempy_pb2.Acquisition</span>
</code></dt>
<dd>
<div class="desc"><p>Encode an acquisition to a Protobuf message</p>
<h2 id="arguments">Arguments</h2>
<p>obj {Acquisition} &ndash; acquisition to be encoded</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>AcquisitionMessage -- encoded acquisition</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def to_protobuf(obj: &#34;Acquisition&#34;) -&gt; AcquisitionMessage:
    &#34;&#34;&#34;Encode an acquisition to a Protobuf message

    Arguments:
        obj {Acquisition} -- acquisition to be encoded

    Returns:
        AcquisitionMessage -- encoded acquisition
    &#34;&#34;&#34;
    acquisition_message = AcquisitionMessage()
    acquisition_message.entity.CopyFrom(Entity.to_protobuf(obj))
    acquisition_message.creation_timestamp = obj.creation_timestamp

    if obj.sync_offset is not None:
        acquisition_message.sync_offset = obj.sync_offset
    if obj.time_unit is not None:
        acquisition_message.time_unit = obj.time_unit
    if obj.owner_id is not None:
        acquisition_message.owner_id = obj.owner_id
    if obj.creator_id is not None:
        acquisition_message.creator_id = obj.creator_id
    if obj.dataset_id is not None:
        acquisition_message.dataset_id = obj.dataset_id

    acquisition_message.subject.CopyFrom(Subject.to_protobuf(obj._subject))
    acquisition_message.devices.extend([Device.to_protobuf(d) for d in obj._devices])
    acquisition_message.has_timeseries_samples = obj.has_timeseries_samples
    acquisition_message.has_image_samples = obj.has_image_samples
    acquisition_message.has_video_samples = obj.has_video_samples

    return acquisition_message</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dempy.acquisitions.acquisition.Acquisition.annotations"><code class="name">var <span class="ident">annotations</span></code></dt>
<dd>
<div class="desc"><p>Annotations' API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def annotations(self):
    &#34;&#34;&#34;Annotations&#39; API&#34;&#34;&#34;
    class Inner:
        _ANNOTATIONS_ENDPOINT = _ENDPOINT + &#34;{}/annotations/&#34;.format(self.id)

        @staticmethod
        def get(annotation_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; AnnotationList:
            &#34;&#34;&#34;Get all the annotations that belong to this acquisition

            Keyword Arguments:
                annotation_id {str} -- id of the annotation (default: {None})
                tags {List[str]} -- tags of the annotation (default: {[]})
                metadata {Dict[str, str]} -- metadata of the annotation (default: {{}})

            Returns:
                AnnotationList -- annotation or annotation of video samples
            &#34;&#34;&#34;
            if annotation_id is None:
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                    annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                        .json(object_hook=Annotation.from_json)
                    return AnnotationList(annotations)

                annotations = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT).json(object_hook=Annotation.from_json)
                for annotation in annotations:
                    cache._cache_data(&#34;annotations&#34;, annotation.id, annotation, Annotation.to_protobuf)
                return AnnotationList(annotations)
            else:
                try:
                    annotation = cache._get_cached_data(&#34;annotations&#34;, annotation_id, Annotation.from_protobuf)
                except FileNotFoundError:
                    annotation = _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + annotation_id).json(object_hook=Annotation.from_json)
                    cache._cache_data(&#34;annotations&#34;, annotation_id, annotation, Annotation.to_protobuf)
                return annotation

        @staticmethod
        def count() -&gt; int:
            &#34;&#34;&#34;Get the number of annotations on this acquisition

            Returns:
                int -- number of annotations
            &#34;&#34;&#34;
            return _api_calls.get(Inner._ANNOTATIONS_ENDPOINT + &#34;count&#34;).json()

    return Inner()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.devices"><code class="name">var <span class="ident">devices</span></code></dt>
<dd>
<div class="desc"><p>Devices' API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def devices(self):
    &#34;&#34;&#34;Devices&#39; API&#34;&#34;&#34;
    class Inner:
        _DEVICES_ENDPOINT = _ENDPOINT + &#34;{}/devices/&#34;.format(self.id)

        @staticmethod
        def get(device_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[Device, List[Device]]:
            &#34;&#34;&#34;Get a device identified by `device_id` or list of devices on this acquisition

            Keyword Arguments:
                device_id {str} -- id of the device (default: {None})
                tags {List[str]} -- tags of the devices (default: {[]})
                metadata {Dict[str, str]} -- metadata of the devices (default: {{}})

            Raises:
                IndexError: device identified by `device_id` does not exist in this acquisition

            Returns:
                Union[Device, List[Device]] -- device or list of devices
            &#34;&#34;&#34;
            if device_id is None:
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    return [d for d in self._devices if
                            len([k for k in d.metadata if k in metadata and d.metadata[k] == metadata[k]]) &gt; 0]

                return self._devices
            else:
                try:
                    device = next((device for device in self._devices if device.id == device_id))
                except StopIteration:
                    raise IndexError(f&#34;device id {device_id} does not exist in acquisition id {self.id}&#34;)
                return device

        @staticmethod
        def usage() -&gt; Dict[str, List[str]]:
            &#34;&#34;&#34;Get a map identifying which device(s) and sensor(s) were used to acquire time series samples

            Returns:
                Mapping[str, List[str]] -- map of (key, value) pairs, with key being id of device and the value
                a list of sensor ids which were used to capture samples
            &#34;&#34;&#34;
            return _api_calls.get(Inner._DEVICES_ENDPOINT + &#34;usage&#34;).json()

        @staticmethod
        def count() -&gt; int:
            &#34;&#34;&#34;Get the number of devices on this acquisition

            Returns:
                int -- number of devices
            &#34;&#34;&#34;
            return len(self._devices)

    return Inner()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.image_samples"><code class="name">var <span class="ident">image_samples</span></code></dt>
<dd>
<div class="desc"><p>Image samples' API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_samples(self):
    &#34;&#34;&#34;Image samples&#39; API&#34;&#34;&#34;
    class Inner:
        _IMAGE_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/images/&#34;.format(self.id)

        @staticmethod
        def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[ImageSample, SampleList]:
            &#34;&#34;&#34;Get all the image samples that belong to this acquisition

            Keyword Arguments:
                sample_id {str} -- id of the sample (default: {None})
                tags {List[str]} -- tags of image samples (default: {[]})
                metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

            Returns:
                Union[ImageSample, SampleList] -- image sample or list of image samples
            &#34;&#34;&#34;
            if sample_id is None:
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                    samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                        .json(object_hook=ImageSample.from_json)
                    return SampleList(samples)

                samples = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT).json(object_hook=ImageSample.from_json)
                for sample in samples:
                    cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample.id, sample, ImageSample.to_protobuf)
                return SampleList(samples)
            else:
                try:
                    sample = cache._get_cached_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, ImageSample.from_protobuf)
                except FileNotFoundError:
                    sample = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id).json(object_hook=ImageSample.from_json)
                    cache._cache_data(&#34;samples/{}/images/&#34;.format(self.id), sample_id, sample, ImageSample.to_protobuf)
                return sample

        @staticmethod
        def raw(sample_id: str) -&gt; ByteString:
            &#34;&#34;&#34;Get actual image from image sample identified by `sample_id` on this acquisition

            Arguments:
                sample_id {str} -- id of the sample

            Returns:
                ByteString -- bytes of the image
            &#34;&#34;&#34;
            try:
                image = cache._get_cached_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
            except FileNotFoundError:
                image = _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                file_ext = &#34;.&#34; + image.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                cache._cache_data(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id + file_ext, image.content)

            return image

        @staticmethod
        def count() -&gt; int:
            &#34;&#34;&#34;Get the number of image samples on this acquisition

            Returns:
                int -- number of image samples
            &#34;&#34;&#34;
            return _api_calls.get(Inner._IMAGE_SAMPLE_ENDPOINT + &#34;count&#34;).json()

        @staticmethod
        def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
            &#34;&#34;&#34;Visualize the image of a sample identified by `sample_id`.
            By default opens the predefined system image application.
            A different callback can be given to open the image.

            Arguments:
                sample_id {str} -- id of the sample

            Keyword Arguments:
                backend {Callable[[str], None]} -- backend to open the image with (default: {None})
            &#34;&#34;&#34;
            self.image_samples.raw(sample_id)
            image_path = cache._build_cache_path(&#34;samples/{}/images/raw/&#34;.format(self.id), sample_id)
            image_path = cache._add_file_extension(image_path)

            if backend is None:
                system = platform.system()

                if system == &#34;Darwin&#34;:
                    subprocess.call((&#34;open&#34;, image_path))
                elif system == &#34;Windows&#34;:
                    os.startfile(image_path)
                else:
                    subprocess.call((&#34;xdg-open&#34;, image_path))
            else:
                backend(image_path)

    return Inner()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.subject"><code class="name">var <span class="ident">subject</span></code></dt>
<dd>
<div class="desc"><p>Subject's API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def subject(self):    
    &#34;&#34;&#34;Subject&#39;s API&#34;&#34;&#34;
    class Inner:
        _SUBJECT_ENDPOINT = _ENDPOINT + &#34;{}/subjects/&#34;.format(self.id)

        @staticmethod
        def get() -&gt; Subject:
            &#34;&#34;&#34;Get subject from acquisition

            Returns:
                Subject -- subject of the acquisition
            &#34;&#34;&#34;
            return self._subject

    return Inner()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.timeseries_samples"><code class="name">var <span class="ident">timeseries_samples</span></code></dt>
<dd>
<div class="desc"><p>Timeseries samples' API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def timeseries_samples(self):
    &#34;&#34;&#34;Timeseries samples&#39; API&#34;&#34;&#34;
    class Inner:
        _TIMESERIES_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/timeseries/&#34;.format(self.id)

        @staticmethod
        def get(tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; SampleList:
            &#34;&#34;&#34;Get all the timeseries samples that belong to this acquisition

            Keyword Arguments:
                tags {List[str]} -- tags of the timeseries samples (default: {[]})
                metadata {Dict[str, str]} -- metadata of the timeseries samples (default: {{}})

            Returns:
                SampleList -- list of timeseries samples
            &#34;&#34;&#34;
            if len(tags) &gt; 0 or len(metadata) &gt; 0:
                processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                    .json(object_hook=TimeseriesSample.from_json)
                samples.sort(key=lambda sample: sample.timestamp)
                return SampleList(samples)

            try:
                samples = cache._get_cached_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, SampleList.from_protobuf)
            except FileNotFoundError:
                samples = _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT) \
                    .json(object_hook=TimeseriesSample.from_json)
                samples.sort(key=lambda sample: sample.timestamp)
                samples = SampleList(samples)
                cache._cache_data(&#34;samples/{}/&#34;.format(self.id), &#34;timeseries&#34;, samples, SampleList.to_protobuf)
            return samples

        @staticmethod
        def count() -&gt; int:
            &#34;&#34;&#34;Get the number of timeseries samples on this acquisition

            Returns:
                int -- number of timeseries samples
            &#34;&#34;&#34;
            return _api_calls.get(Inner._TIMESERIES_SAMPLE_ENDPOINT + &#34;count&#34;).json()

        @staticmethod
        def visualize(device_id: str, sensor_id: str = None) -&gt; None:
            &#34;&#34;&#34;Graphically visualize the timeseries samples of a device identified by `device_id` 
            or of a given sensor identified by `sensor_id` of said device

            Arguments:
                device_id {str} -- id of the device

            Keyword Arguments:
                sensor_id {str} -- id of the sensor (default: {None})
            &#34;&#34;&#34;
            def visualize_sensor_samples(axis, sensor, sensor_samples):
                timestamps = [s.timestamp for s in sensor_samples]

                # Sample x, y, z, u, w
                samples_x = [s.x for s in sensor_samples if hasattr(s, &#34;x&#34;)]
                samples_y = [s.y for s in sensor_samples if hasattr(s, &#34;y&#34;)]
                samples_z = [s.z for s in sensor_samples if hasattr(s, &#34;z&#34;)]
                samples_u = [s.u for s in sensor_samples if hasattr(s, &#34;u&#34;)]
                samples_w = [s.w for s in sensor_samples if hasattr(s, &#34;w&#34;)]

                # Title and x label
                axis.set_title(f&#34;{sensor.sensor_type}\n{sensor.id}&#34;, loc=&#34;left&#34;)
                axis.set_xlabel(sensor.time_unit if sensor.time_unit is not None else device_time_unit)

                # Axis limit
                axis.set_xlim([0, timestamps[-1]])
                axis.set_ylim([min(chain(samples_x, samples_y, samples_z, samples_u, samples_w)),
                               max(chain(samples_x, samples_y, samples_z, samples_u, samples_w))])

                # Axis formatter
                axis.xaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))
                axis.yaxis.set_major_formatter(ticker.FormatStrFormatter(&#34;%.0f&#34;))

                # Axis plot
                labels = []

                if len(samples_x) &gt; 0:
                    axis.plot(timestamps, samples_x, color=&#34;cornflowerblue&#34;)
                    labels.append(&#34;x&#34;)
                if len(samples_y) &gt; 0:
                    axis.plot(timestamps, samples_y, color=&#34;mediumseagreen&#34;)
                    labels.append(&#34;y&#34;)
                if len(samples_z) &gt; 0:
                    axis.plot(timestamps, samples_z, color=&#34;indianred&#34;)
                    labels.append(&#34;z&#34;)
                if len(samples_u) &gt; 0:
                    axis.plot(timestamps, samples_u, color=&#34;mediumorchid&#34;)
                    labels.append(&#34;u&#34;)
                if len(samples_w) &gt; 0:
                    axis.plot(timestamps, samples_w, color=&#34;slategray&#34;)
                    labels.append(&#34;w&#34;)

                axis.legend(labels=labels, loc=&#34;upper right&#34;)

            device = self.devices.get(device_id=device_id)
            device_time_unit = device.time_unit if device.time_unit is not None else self.time_unit

            if sensor_id is None:
                fig, axs = plt.subplots(nrows=device.sensors.count(), figsize=(15, 10), dpi=80, constrained_layout=True)
                fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                device_samples = self.timeseries_samples.get().by_device(device_id=device.id)

                for i, sensor in enumerate(device.sensors.get()):
                    visualize_sensor_samples(axs[i], sensor, device_samples.by_sensor(sensor.id))
            else:
                fig, ax = plt.subplots(nrows=1, figsize=(10, 4), dpi=80, constrained_layout=True)
                fig.suptitle(f&#34;{device.model_name} ({device.manufacturer})\n{device.id}&#34;, wrap=True)

                sensor_samples = self.timeseries_samples.get().by_sensor(sensor_id)

                visualize_sensor_samples(ax, device.sensors.get(sensor_id=sensor_id), sensor_samples)

            plt.show()

    return Inner()</code></pre>
</details>
</dd>
<dt id="dempy.acquisitions.acquisition.Acquisition.video_samples"><code class="name">var <span class="ident">video_samples</span></code></dt>
<dd>
<div class="desc"><p>Video samples' API</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def video_samples(self):
    &#34;&#34;&#34;Video samples&#39; API&#34;&#34;&#34;
    class Inner:
        _VIDEO_SAMPLE_ENDPOINT = _ENDPOINT + &#34;{}/samples/videos/&#34;.format(self.id)

        @staticmethod
        def get(sample_id: str = None, tags: List[str] = [], metadata: Dict[str, str] = {}) -&gt; Union[VideoSample, SampleList]:
            &#34;&#34;&#34;Get all the video samples that belong to this acquisition

            Keyword Arguments:
                sample_id {str} -- id of the sample (default: {None})
                tags {List[str]} -- tags of image samples (default: {[]})
                metadata {Dict[str, str]} -- metadata of the image samples (default: {{}})

            Returns:
                Union[VideoSample, SampleList] -- video sample or list of video samples
            &#34;&#34;&#34;
            if sample_id is None:
                if len(tags) &gt; 0 or len(metadata) &gt; 0:
                    processed_metadata = {f&#34;metadata.{k}&#34;: metadata[k] for k in metadata}
                    samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT, params={&#34;tags&#34;: tags, **processed_metadata}) \
                        .json(object_hook=VideoSample.from_json)
                    return SampleList(samples)

                samples = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT).json(object_hook=VideoSample.from_json)
                for sample in samples:
                    cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample.id, sample, VideoSample.to_protobuf)
                return SampleList(samples)
            else:
                try:
                    sample = cache._get_cached_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, VideoSample.from_protobuf)
                except FileNotFoundError:
                    sample = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id).json(object_hook=VideoSample.from_json)
                    cache._cache_data(&#34;samples/{}/videos/&#34;.format(self.id), sample_id, sample, VideoSample.to_protobuf)
                return sample

        @staticmethod
        def raw(sample_id: str) -&gt; ByteString:
            &#34;&#34;&#34;Get actual video from video sample identified by `sample_id` on this acquisition 

            Arguments:
                sample_id {str} -- id of the sample

            Returns:
                ByteString -- bytes of the video
            &#34;&#34;&#34;
            try:
                video = cache._get_cached_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
            except FileNotFoundError:
                video = _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + sample_id + &#34;/raw&#34;)
                file_ext = &#34;.&#34; + video.headers[&#34;Content-Type&#34;].split(&#34;/&#34;)[-1]
                cache._cache_data(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id + file_ext, video.content)

            return video

        @staticmethod
        def count() -&gt; int:
            &#34;&#34;&#34;Get the number of video samples on this acquisition

            Returns:
                int -- number of video samples
            &#34;&#34;&#34;
            return _api_calls.get(Inner._VIDEO_SAMPLE_ENDPOINT + &#34;count&#34;).json()

        @staticmethod
        def visualize(sample_id: str, backend: Callable[[str], None] = None) -&gt; None:
            &#34;&#34;&#34;Visualize the video of a sample identified by `sample_id`.
            By default opens the predefined system video application.
            A different callback can be given to open the video.

            Arguments:
                sample_id {str} -- id of the sample

            Keyword Arguments:
                backend {Callable[[str], None]} -- backend to open the video with (default: {None})
            &#34;&#34;&#34;
            self.video_samples.raw(sample_id)
            video_path = cache._build_cache_path(&#34;samples/{}/videos/raw/&#34;.format(self.id), sample_id)
            video_path = cache._add_file_extension(video_path)

            if backend is None:
                system = platform.system()

                if system == &#34;Darwin&#34;:
                    subprocess.call((&#34;open&#34;, video_path))
                elif system == &#34;Windows&#34;:
                    os.startfile(video_path)
                else:
                    subprocess.call((&#34;xdg-open&#34;, video_path))
            else:
                backend(video_path)

    return Inner()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dempy.acquisitions" href="index.html">dempy.acquisitions</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dempy.acquisitions.acquisition.count" href="#dempy.acquisitions.acquisition.count">count</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.get" href="#dempy.acquisitions.acquisition.get">get</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dempy.acquisitions.acquisition.Acquisition" href="#dempy.acquisitions.acquisition.Acquisition">Acquisition</a></code></h4>
<ul class="two-column">
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.annotations" href="#dempy.acquisitions.acquisition.Acquisition.annotations">annotations</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.devices" href="#dempy.acquisitions.acquisition.Acquisition.devices">devices</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.from_json" href="#dempy.acquisitions.acquisition.Acquisition.from_json">from_json</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.from_protobuf" href="#dempy.acquisitions.acquisition.Acquisition.from_protobuf">from_protobuf</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.image_samples" href="#dempy.acquisitions.acquisition.Acquisition.image_samples">image_samples</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.subject" href="#dempy.acquisitions.acquisition.Acquisition.subject">subject</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.timeseries_samples" href="#dempy.acquisitions.acquisition.Acquisition.timeseries_samples">timeseries_samples</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.to_protobuf" href="#dempy.acquisitions.acquisition.Acquisition.to_protobuf">to_protobuf</a></code></li>
<li><code><a title="dempy.acquisitions.acquisition.Acquisition.video_samples" href="#dempy.acquisitions.acquisition.Acquisition.video_samples">video_samples</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>